---
layout: single
title:  "8.소프트웨어 공학 설계 (추상화)"
categories: software
tags: [Major, Software]
toc: true
author_profile: false
---


# 1. 설계의 이해

## 설계
### 건물 건축과 소프트웨어 설계
- 건축: 건축주와 설계사가 의견 교환을 통해 도면을 확정하면 최종 산출물로 설계 도면이 만들어지고 이를 기반으로 건설
- 소프트웨어: 요구분석명세서를 작성 후 이를 참조해 개발팀에서 설계서를 만든 후 이를 기반으로 구현 작업에 착수

### 요구 분석과 설계의 차이

| 구분      | 요구분석                                                         | 설계                                             |
| :------ | ------------------------------------------------------------ | ---------------------------------------------- |
| **산출물** | 요구분석명세서                                                      | 설계서                                            |
| **관점**  | 무엇(what)                                                     | 어떻게(how)                                       |
| **특성**  | 개념적, 추상적                                                     | 사용 환경을 반영해 구체적                                 |
| **비고**  | 미고려 대상: 운영체제, DBMS(오라클, MS-SQL Server 등), 프레임워크(NET, J2EE 등) | 고려 대상: 비기능 요구사항, 제약 사항, 플랫폼: 운영체제, 미들웨어, 프레임워크 |

### 좋은 설계가 되기 위한 조건
- 설계서는 요구분석명세서의 내용을 모두 포함해야 함
- 유지보수가 용이하도록 추적이 가능해야 함
- 변화에 쉽게 적응할 수 있어야 함
- 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 함
- 설계서는 읽기 쉽고 이해하기 쉽게 작성해야 함



# 2. 설계의 원리
## 분할과 정복
### 분할과 정복의 개요
- 분할: 큰 소프트웨어 하나를 개발할 때 여러 개의 서브시스템으로 세분화해 나누는 작업
- 정복 어느 정도 수준까지 분할했다면 말단에 있는 것부터 하나씩 개발하는 작업

### 분할과 정복의 원리
- 프로젝트를 수행할 때 먼저 작은 단위로 분할한 뒤 말단에 있는 작은 시스템부터 개발하면서 하나씩 위로 올라가며 완성

### 분할의 기준
- 분산 시스템은 클라이언트와 서버로 분할
- 시스템은 여러 서브시스템으로 분할
- 서브시스템은 하나 이상의 패키지로 분할
- 패키지는 유스케이스나 여러 클래스로 분할

### 분할의 주의사항
- 여러 개의 모듈로 분할하면 모듈끼리 통신 횟수가 많아지면서 모듈로 분할하는 장점보다 복잡도가 오히려 증가할 수 있음
- 설계자는 어느 수준까지 모듈을 분할할지 결정할 때 복잡도 증가로 인한 부작용과 모듈 분할로 얻는 이득을 함께 고려

## 추상화
### 추상화의 개요
- 자신에게 필요한 특징만 표현한 것
- 등산가는 등산로 그림이 필요하고 지형을 연구하는 사람은 등고선 그림이 필요
- 전기 배선 공사 담당자에 게는 전기 배선도, 배관 설치 담당자에게는 상하수도 배관도가 필요

- 주어진 문제에서 현재의 관심사에 초점을 맞추기 위해 특정한 목적과 관련된 필수 정보만 추출해 강조
- 관련 없는 세부 사항은 생략해 본질적인 문제에 집중할 수 있도록 하는 작업

### 객체지향 설계에서 추상화의 의미
유사한 특성을 가진 것끼리 그룹화한 뒤 공통점을 뽑아 이름을 붙이는 것

![sw_5_1]({{site.url}}/assets/images/2024-3-1-softw/sw_5_1.png)

### 과정 추상화
주어진 문제에 대해 프로그래밍하기 전에 상세 부분은 생략하고 전체 흐름만 파악할 수 있는 알고리즘 형태로 작성하는 것

### 과정 추상화 예시
- 학점을 구하는 과목의 이름은 구체적으로 언급하지 않고 `합계 및 평균을 구한다` 라고만 표현
- 과목의 점수 합계를 정렬할 때도 구체적인 방법(버블 정렬, 퀵 정렬, 선택 정렬 등)은 언급하지 않고 `정렬한다` 라고만 표현
- main( ) 함수에서 GetSum( )이라는 함수명은 한 줄로 표현했지만 이 함수의 구현 부분은 5줄짜리 코드

![sw_5_2]({{site.url}}/assets/images/2024-3-1-softw/sw_5_2.png)



### 데이터 추상화
- 데이터와 데이터 구조를 감추는 것으로 대표적인 예가 C++ 언어의 클래스
- 데이터와 메서드를 클래스 형태로 캡슐화해 숨겨 놓고 사용자에게는 꼭 필요한 기능만 사용할 수 있게 개방한 구조

#### 데이터 추상화 예시(스택)
- 데이터가 1개씩 증가할 때마다 스택 안에 쌓임(push( ))
- 1개씩 감소할 때마다 스택 안에 있는 요소를 1개씩 제거(pop( ))

![sw_5_3]({{site.url}}/assets/images/2024-3-1-softw/sw_5_3.png)


### 제어 추상화
- 프로그래밍 언어에서 쓰는 제어 구조를 추상화
- 제어 추상화는 단계가 올라갈수록 표현이 더욱 간결해지고 특징만 나타낸다는 장점
- 프로그래밍에서 조건을 나타내는 if 문이나 반복을 나타내는 for 문도 사용자가 사용하기 쉽게 추상화한 것

### 제어 추상화 예시
- (a)는 C 언어와 같은 고급 언어로 표현한 것이고 (b)는 이를 어셈블리 언어, (c)는 기계 언어

![sw_5_4]({{site.url}}/assets/images/2024-3-1-softw/sw_5_4.png)


# 2. 설계의 원리
## 캡슐화
### 캡슐화의 개요
- 전자제품은 내부가 어떻게 구성되어 있으며 어떤 방식으로 돌아가는지 몰라도 기능과 사용법을 아는게 중요함
- 사용자에게 해당 객체의 기능(서비스)과 사용법만 제공해 사용하기 쉽게 하고 내부는 함부로 변경할 수 없게 감추는 개념
- 블랙 박스와 같은 것으로 클래스를 사용해 서로 관련된 정보와 처리 방식을 같이 묶고 외부에는 감추어두는 것

![sw_5_5]({{site.url}}/assets/images/2024-3-1-softw/sw_5_5.png)



### 캡슐화의 장점
- 추상화를 통해 문제를 쉽게 개념화할 수 있음
- 객체 제공자와 객체 이용자(외부 객체)를 명확히 분리할 수 있음
- 메서드의 구현 방법이 바뀌어도 사용자에게는 영향을 미치지 않아 사용하기 쉬음
- 메서드의 기능만 알면 객체를 쉽게 사용할 수 있음
- 객체 내 자료구조나 알고리즘이 바뀌어도 다른 객체에 미치는 영향이 적음
- 캡슐화(데이터+메서드)로 객체 사이의 독립성이 구조적으로 보장
- 그 객체와 인터페이스로 통신하는 사용자에게는 영향을 주지 않으므로 부담 없이 자료구조를 변경할 수 있음
- 프로그램을 개발할 때 제공하는 기능만 알면 되므로 사용자(프로그래머)가 모듈을 이해하기 쉬움
- 모듈 내의 데이터와 알고리즘을 변경하기 쉬우므로 기능을 추가하기도 쉬움



## 정보은닉
### 정보은닉의 개요
- 타인이 무슨 생각을 하는지 알아내려면 많은 대화를 통해 생각을 알아내야 함
- 외부(다른 객체)에서 객체의 내부(데이터)를 들여다볼 수 없다는 개념
- 캡슐화는 캡슐의 내부와 외부를 구분하지만 그 자체로 내부 정보가 외부에 숨겨지지는 않음 이때 정보은닉이 필요함

### 정보은닉의 속성
#### +(공개, public)
- public으로 설정된 요소는 같은 시스템에 있는 모든 클래스가 접근할 수 있음
- 클래스는 클래스 이름, 속성, 메서드로 구성되는데 public으로 설정되는 부분은 주로 메서드

#### -(은닉, private)
- private으로 설정된 요소는 같은 시스템 내의 다른 클래스가 직접 접근 할 수 없음
- 해당 클래스의 메서드를 통해서만 접근할 수 있음
- 클래스에서 대부분의 속성은 private으로 설정

#### #(부분 공개, protected)
- protected로 설정된 요소는 다른 클래스가 접근할 수 없음
- 해당 클래스의 메서드와 클래스를 상속받은 하위 클래스만 접근

![sw_5_6]({{site.url}}/assets/images/2024-3-1-softw/sw_5_6.png)

![sw_5_7]({{site.url}}/assets/images/2024-3-1-softw/sw_5_7.png)




## 상속
### 상속의 개요
- 상위 클래스의 모든 것을 하위 클래스가 물려받아 내 것처럼 사용함을 의미
- 물려주는 클래스: 상위 클래스 또는 부모 클래스  /  물려받는 클래스: 하위 클래스 또는 자식 클래스
- 클래스 간의 상속 관계는 속이 빈 삼각형 모양의 화살표를 사용

### 상속의 장점
- 상속 관계를 이용하면 개별 클래스를 상속 관계로 묶어서 구조를 파악하기 쉬움
- 상속 관계에 속한 클래스, 데이터, 메서드를 추가하기도 쉬움
- 데이터와 메서드를 변경할 때 상위에 있는 것만 수정할 수 있음

![sw_5_8]({{site.url}}/assets/images/2024-3-1-softw/sw_5_8.png)



## 다형성
### 오버로딩(중복 정의)
#### 연산자 중복 정의
- +기호: `3+5` 처럼 두 수를 더하는 연산자로 사용  /  `go+stop` 이 라고 쓰면 문자열을 연결하는 연결자 역할
- +기호가 서로 다른 용도로 사용되는 경우를 `연산자 중복 정의` 라고 함

#### 메서드 중복 정의
- C 언어의 경우에는 한 모듈 안에 동일한 함수명을 사용하는 것이 문법적으로 불가능하지만 객체지향 언어에서는 가능
- 한 클래스 안에서 이름이 같은 메서드를 중복해서 사용할 수 있음

#### 같은 메서드를 구별하는 법
- 첫째: 매개변수의 개수로 구별
- 둘째: 매개변수의 자료형으로 구별
- 시그니처: 동일한 메서드가 호출되었을 때 구별할 수 있는 매개변수의 개수나 자료형 같은 요소

### 오버라이딩(재정의)
#### 메서드 재정의
- 상위 클래스에서 정의한 메서드는 무시하고 하위 클래스 에서 다시 정의해 사용하는 것
- 메서드 재정의를 잘못 사용하면 설계 원칙에 위배
- 예시) 상위 클래스도 일반 클래스이고 메서드도 일반 메서드를 사용하고 있어 리스코프 교체 원칙을 위반
	- 추상 클래스와 추상 메서드를 사용하면 리스코프 교체 원칙을 위반하지 않음
	- 리스코프 교체 원칙: 상위 클래스의 객체는 언제나 자신의 하위 클래스의 객체로 교체할 수 있어야 함

![sw_5_9]({{site.url}}/assets/images/2024-3-1-softw/sw_5_9.png)


