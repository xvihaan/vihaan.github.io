---
layout: single
title:  "[Linux] 7. 파일시스템과 디스크 관리하기(1)"
categories: linux
tags: [Major, OS]
toc: true
author_profile: false
---

# 1. 리눅스 파일 시스템의 종류

## 파일 시스템
- 파일과 디렉터리 집합을 구조적으로 관리하는 체계
- 다양한 형식의 파일 시스템 존재(FAT, NTFS, EXT, 등)

### 리눅스 디스크 기반 파일 시스템
- `etx(etx1)` 
		- Extended File System
		- 파일 시스템의 최대 크기는 2GB, 파일 이름의 길이는 255바이트까지 지원
- `ext2`
	- 파일 시스템의 최대 크기는 이론적으로 32TB까지 가능 (초기 2TB까지 지원)
- `ext3`
	- ext3의 가장 큰 장점은 저널링 기능을 도입하여 파일시스템 복구기능을 강화
	- 파일 시스템의 최대 크기는 블록의 크기에 따라 2~32TB까지 지원
- `ext4`
	- 1EB(엑사바이트) 이상의 볼륨과 16TB 이상의 파일을 지원
	- ext2 및 ext3와 호환성 유지
- `XFS`
	- eXtended File System
	- XFS는 64bit 파일 시스템으로 최대 16EB 까지 지원

### 리눅스는 `ext`, `ext2`, `ext3`, `ext4` 이외에 다양한 파일 시스템을 지원함
- `msdos, vfat, nfts` (Microsoft 파일 시스템) 
- `hfs` (Apple 파일 시스템)
- `iso9660` (CD-ROM, DVD 파일 시스템)

| 항목      | 기능                                                    |
| :-------- | :------------------------------------------------------ |
| `msdos`   | MS-DOS 파티션을 사용하기 위한 파일 시스템               |
| `vfat`    | 윈도우 95,98,NT를 지원하기 위한 파일 시스템             |
| `ntfs`    | 윈도우의 NTFS를 지원하기 위한 파일 시스템               |
| `hfs`     | 맥 컴퓨터의 hfs 파일 시스템을 지원하기 위한 파일 시스템 |
| `iso9660` | CD-ROM, DVD의 표준 파일 시스템으로 읽기 전용으로 사용   |

### 현재 시스템이 지원하는 파일 시스템 확인하기
- `/proc/filesystems` 는 현재 커널이 지원하는 파일 시스템의 종류를 알려줌
```
nodev   devpts
		ext3
		ext4
		squashfs
		vfat
nodev	ecryptfs
		fuseblk #ntfs
nodev
nodev
nodev	autofs
		iso9660
```
`nodev`: 가상 파일 시스템 의미

---


# 2. 리눅스 파일 시스템의 주요 특징
### 리눅스 파일 시스템의 주요 특징
- 파일은 `inode 테이블`로 관리
- 디렉터리는 단순한 파일의 목록을 가지고 있는 파일
- 특수 파일을 통해 장치에 접근할 수 있음

### 우분투 리눅스 파일 시스템(`ext4`) 의 구조
- 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록그룹)으로 구분하여 관리함 (하나의 블록그룹은 최대 32,768개의 블록으로 구성)
- 일반적으로 한 블록의 크기는 4KB이고 실제 크기는 시스템의 설정에 따라 변경 가능함

#### 블록그룹의 3가지 유형
- 모든 블록그룹은 기본적으로 `데이터 블록 비트맵(1블록)`, `inode 비트맵(1블록)`, `inode 테이블(n블록)`, `데이터블록(n블록)`을 가지고 있음
- `블록그룹 0` : 전체 파일 시스템의 첫 번째 블록그룹으로 특별하게 `그룹 0 패딩`과 `슈퍼블록`, `그룹 디스크립터 블록`, `그룹 디스크립터 예약 블록` 정보를 저장
- `블록그룹 a` : `슈퍼블록`과 `그룹 디스크립터 블록`, `그룹 디스크립터 예약 블록`에 대한 `복사본 정보`를 저장함
- `블록그룹 b` : 일반 블록

### `ext4` 파일 시스템의 블록그룹 유형
#### 블록그룹 0 - `파일 시스템에 도착하면 딱 1개만 생성`

|그룹 0 패딩|ext4 슈퍼블록|그룹 디스크립터(GDT)|GDT 예약 블록|데이터 블록 비트맵|inode 비트맵|inode 비트맵|데이터블록|
|:---|:---|:---|:---|:---|:---|:---|:---|
|1,024B|1 블록|n 블록|n 블록|1 블록|1 블록|n 블록|n 블록|

#### 블록그룹 a - `여러 개 생성`

|ext4 슈퍼블록|그룹 디스크립터|GDT 예약 블록|데이터 블록 비트맵|inode 비트맵|inode 비트맵|데이터블록|
|:---|:---|:---|:---|:---|:---|:---|
|1 블록|n 블록|n 블록|1 블록|1 블록|n 블록|n 블록|

#### 블록그룹 b - `나머지(제일 많이 생성)`

|데이터 블록 비트맵|inode 비트맵|inode 비트맵|데이터블록|
|:---|:---|:---|:---|
|1 블록|1 블록|n 블록|n 블록|

### `ext4` 파일 시스템의 구조
#### `그룹 0 패딩` (1,024B, 1K)
- `부트 섹터`와 `부가 정보` 저장



#### `슈퍼블록` (1블록, 4K)
- 전체 파일 시스템의 구성과 관련된 정보들 저장
	- `파일시스템 크기. 전체 블록 개수, 전체 inode 개수, 각 블록 크기, 그룹 당 블록 개수, 마운트 시간` 등
- `슈퍼블록`은 해당 디스크가 마운트 될 때, 운영체제가 가장 먼저 읽음
- `슈퍼블록`에 문제가 생길 경우 전체 파일 시스템을 사용할 수 없음
- `슈퍼블록`은 다른 블록그룹에 복사하고, 슈퍼블록을 읽을 수 없을 경우 복사본을 사용하여 복구함 (블록그룹 a를 이용)



#### 그룹 디스크립터 테이블(GDT)과 GDT 예약 블록
- `그룹 디스크립터 테이블`도 다른 블록그룹에 복사됨
- GDT에 저장되는 정보 (블록그룹에 대한 정보 저장)
	- `데이터 블록 비트맵 주소, inode 비트맵 주소, inode 테이블 주소, 할당되지 않은 블록의 개수, 할당되지 않은 inode의 개수, 디렉터리의 개수`
- `GDT 예약 블록`은 그룹 디스크립터 테이블의 확장을 위한 예비 공간임



#### 데이터 블록 비트맵과 inode 비트맵 (1이면 사용 중, 0이면 사용 중이 아님)
- 블록그룹에 포함된 `데이터 블록의 사용 여부 표시`
- 블록그룹에 포함된 `inode 테이블 항목의 사용 여부 표시`



#### 데이터 블록과 inode 테이블
- 데이터 블록에는 `실제 데이터`들이 저장됨
- inode 테이블에는 `실제 파일/디렉터리에 관한 정보`들이 저장됨



#### inode의 구조 (inode 테이블에서 한 개의 행을 추출하였을 때)
- 파일종류, 파일 접근권한, 파일크기, 소유자, 접근시간 등의 정보 저장(`ls -l`)
- 테이블 블록의 주소 저장 (`7개의 주소 => 7개 blocks(7 x 4K = 28K)`)



### 파일 시스템을 디렉터리 계층 구조에 연결 (`=마운트`)

#### 전체 디렉터리 구성을 `한 개의 파일 시스템`으로 구성하기


#### 전체 디렉터리 구성을 `여러 개의 파일 시스템`으로 구성하기


### 한 개의 파일 시스템으로 구성하기
**디렉터리 구조에서 보이는 모든 디렉터리와 파일을 하나의 파일 시스템으로 구성**

### 여러 개의 파일 시스템으로 구성하기
**디렉터리 계층 구조를 여러 개의 파일 시스템으로 구분하여 구성**
여러 파일 시스템으로 나누어 디렉터리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템의 파일은 안전함
**Windows에서 C 드라이브, D 드라이브를 구분하는 것과 유사한 개념임**

### 파일 시스템과 디렉터리 계층 구조
디렉터리 계층 구조는 리눅스의 전체 파일과 디렉터리를 어떤 구조로 정리하고 관리할 것인지를 정의한 것임
**실제 파일이 저장되는 파일 시스템은 디렉터리 계층 구조와 연결되어야 사용자가 사용 가능함**
(`=마운트`가 되어야 사용 가능함)

---


## 3. 파일 시스템 마운트
### 마운트
- 파일 시스템을 디렉터리 계층 구조의 특정 디렉터리와 연결하는 것

### 마운트 포인트
- 디렉터리 계층 구조에서 `파일 시스템이 연결`되는 디렉터리를 의미

### 파일 시스템에 대한 마운트 설정 파일
- 리눅스 시스템이 부팅될 때 자동으로 파일 시스템이 마운트 되게 하려면 `/etc/fstab` 파일에 설정하면 됨
- `$ cat /etc/fstab`

### `/etc/fstab` 파일구조

| 장치명 (`파일 시스템 명`) | 마운트 포인트 | 파일 시스템의 종류 | 옵션 | 덤프 관련 설정 | 파일 점검 옵션 |
| :------------------------ | :------------ | :----------------- | :--- | :------------- | :------------- |
||||||

디스크 이름과 장치명은 다름

#### `/etc/fstab` 파일의 예제
- 장치명 : `UUID=7009cb18-dbd5-4ffc-af86-599cee765454` (UUID로 장치명 표시)
- 마운트 포인트 : `/` (루트 디렉터리를 파일시스템과 연결)
- 파일 시스템의 종류 : `etx4` (ext4 파일시스템 설정)
- 옵션 : `errors=remount-ro` (에러가 발생하면 읽기 전용으로 다시 마운트)
- 덤프 관련 설정 : `0` (백업 등을 위해 파일 덤프 사용 안함)
- 파일 점검 옵션 : `1` (부팅 시, 루트 파일 시스템 점검 수행), `2` (부팅 시, 루트 파일 시스템 외의 파일시스템 점검)

- 장치명 : 파일 시스템 장치명으로, 예를 들어 `/dev/hda1`, `/dev/sda1` 과 같이 특정 디스크를 저장함
	- `UUID`는 파일 시스템을 유일하게 구분해주는 `128비트`의 숫자로, 시스템의 하드웨어 정보와 시간 정보를 조합하여 랜덤으로 생성됨
	- `UUID`로 지정된 실제 디스크 장치명은 `/dev/disk/by-uuid` 디렉터리에서 확인 가능함
	- `$ ls -l /dev/disk/by-uuid` 
- 마운트 포인트 : 파일 시스템이 연결되는 디렉터리 이름
- 파일 시스템의 종류 : 파일 시스템의 종류 설정, ext2, ext3, ext4 등
- 옵션 : 파일 시스템의 속성을 지정
- 덤프 관련 설정 : `0`(dump 불가), `1`(dump 가능)
- 파일 점검 옵션 : `0`(부팅 시, 파일시스템 점검 안함), `1`(루트 파일시스템 점검), `2`(루트 파일 시스템 이외의 파일시스템 점검)

### `mount`, `umount` -마운트 관련 명령
- `mount [옵션][장치명][마운트포인트]`
- `umount [옵션][장치명]또는[마운트포인트]`

|`mount`|
|:---|:---|
|기능|파일 시스템을 마운트한다|
|형식|`mount [옵션][장치명 또는 마운트포인트]`|
|옵션|`-t 파일시스템 종류` : 파일 시스템 종류를 지정, `-o 마운트 옵션` : 마운트 옵션을 지정한다, `-f` : 마운트할 수 있는지 점검만 한다, `-r` : 읽기만 가능하게 마운트 한다(`-o`, `-ro` 와 동일)|
|사용 예|`mount` , `mount /dev/sdb1 /` , `mount -t iso9660 /dev/cdrom /mnt/cdrom`|

|`umount`|
|:---|:---|
|기능|파일 시스템을 언마운트한다|
|형식|`umount [옵션][장치명 또는 마운트포인트]`|
|옵션|`-t 파일시스템 종류` : 파일 시스템 종류를 지정한다 (거의 안씀)|
|사용 예|`umount /dev/sdb1 /` , `umount /mnt` (`/dev/sdb1`, `/mnt` 둘중에 하나 사용)|

### 현재 마운트 되어 있는 정보 출력
- `$ mount`
- `$ mount | grep sda`
- 옵션, 인자 없이 `mount 명령만 사용하면 현재 마운트 되어 있는 정보 출력`
- mount 명령으로 출력되는 정보는 `/etc/mtab` 파일의 내용
	- 장치명
	- 마운트 포인트
	- 파일 시스템의 종류
	- 마운트 옵션
- ex) `/dev/sda5 on` , `/type ext4 (rw,realtime,errors=remount-ro)`

### `mount` 명령으로 장치(디스크)를 디렉터리에 연결하는 방법
`mount [옵션][장치명][마운트포인트]`
- ext2 파일 시스템 : `mount -t ext2 /dev/sdb1 /mnt`
- ext3 파일 시스템 : `mount -t ext3 /dev/sdb1 /mnt`
- ext4 파일 시스템 : `mount -t ext4 /dev/sdb1 /mnt` (기본은 ext4)
- 읽기 전용 : `mount -r /dev/sdb1 /mnt`
- CD-ROM : `mount -t iso9660 /dev/cdrom /mnt/cdrom`
- MS Windows 디스크 : `mount -t vfat /dev/hdc /mnt`

### USB 메모리 연결하기(`MS Windows용 USB를 포맷없이 그대로 이용`)
1. USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식시키기
2. `root` 권한으로 새로 연결된 USB 메모리의 `장치명(파일시스템명)`을 확인 (`sudo fdisk -l`)
3. USB 메모리를 `/home/user1/linux_ex/ch7/mttest` 디렉터리에 마운트하고 확인
(`ch7/mttest 디렉터리 생성`)
(`sudo mount -t vfat /dev/sdb1 /home/user1/linux_ex/ch7/mttest`)
(마운트가 잘 되었는지 mttest 디렉터리 내용을 `ls -l` 명령으로 확인)
4. USB 메모리를 사용 완료 후, `umount` 명령으로 마운트 해제
(`sudo umount /dev/sdb1`)

1. USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식 시킴
2. 새로 연결된 USB 메모리의 파일시스템명을 확인함 (`sudo fdisk -l` 이용)
`$ sudo fdisk -l | grep sd` (보통 `/dev/sdb1`임)

### USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식시키는 방법
1. VMware Player의 Player 메뉴의 Removable Device에서 `USB Storage Device의 Connect(Disconnect from host)` 선택
2. USB 장치가 호스트 OS(윈도우)에서 분리되어 게스트 OS인 리눅스에 연결된다는 메시지 출력

### USB 메모리 연결하기(윈도우용)
USB 메모리를 `/home/user1/lunux_ex/ch7/mttest` 디렉터리에 마운트하고 확인
```
$ sudo mount -t vfa /dev/sdb1 /home/user1/lunux_ex/ch7/mttest
$ ls -l /home/user1/linux_ex/ch7/mttest
```

USB 메모리를 사용 완료 후, `umount` 명령으로 마운트 해제
`$ sudo umount /dev/sdb1`

### USB 메모리 연결하기(Windows용 USB를 리눅스용 파일시스템으로 바꾸어 사용)
1. USB 메모리를 USB 슬롯에 연결하고 리눅스 시스템에 인식시키기
2. 새로 연결된 USB 메모리의 디스크명을 확인 (`fdisk -l`)
3. USB 메모리에 파티션 생성 (`fdisk`)
4. 생성된 USB 메모리 파티션을 포맷하여 리눅스 파일시스템(`ext4`) 생성 (`mke2fs`)
5. USB 메모리를 마운트(디렉터리에 연결)하고 확인 (`mount`)
6. 테스트를 위하여 USB 메모리에 새로운 파일 복사해보기 (`cp`)
7. 장치 연결을 해제하고 USB 제거 (`unmount`)

#### USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식시키기
1. `VMware Player의 Player 메뉴의 Removable Device에서 USB Storage Device의 Connect(Disconnect from host) 선택 (앞의 방식과 동일)`
2. `USB 장치가 호스트 OS(윈도우)에서 분리되어 게스트 OS인 리눅스에 연결된다는 메시지 출력 (앞의 방식과 동일)`
3. USB 메모리는 리눅스 `Gnome UI`에서 자동으로 마운트가 되므로 파티션 및 포맷을 수행하기 전에 자동 마운트 정보를 제거해야 함 
4. `mount` 명령을 실행해보면 자동 마운트 정보 확인이 가능함
5. 마운트를 해제하고 파일 시스템 생성 작업을 해야함

#### 파일 시스템 마운트 실습 순서
1)  USB 메모리는 리눅스 `Gnome UI`에서 자동으로 마운트가 되므로 파티션 및 포맷을 수행하기 전에 자동 마운트 정보를 제거해야 함 , `mount` 명령을 실행해보면 자동 마운트 정보 확인이 가능함
    `$ sudo mount | grep sd`



2. 마운트를 해제하고 리눅스용 파일 시스템 생성 작업을 해야함(`umount`)
   `$ sudo umount /ev/sdb1`



3. USB 메모리의 디스크명 확인: `fdisk -l` 명령으로 확인 가능(`root 권한`)
   `$ sudo fdisk -l | grep sd` (`/dev/sdb` 확인)



4. USB 메모리에 파티션 생성 (`fdisk` 명령 사용)



5. USB 메모리 디스크명(`/dev/sdb`)을 이용하여 `fdisk` 명령 실행 
   `$ sudo fdisk /dev/sdb `
   `m 입력`: 파티션에서 사용할 수 있는 명령에 대한 `help` 출력



6. 새로운 파티션을 생성을 위하여 `n` 입력: `default` 선택
       만약, 모든 공간이 사용 중이라고 나오면 기존의 파티션을 삭제(`d` 입력)하고 다시 파티션을 생성



7. 생성할 파티션의 번호를 지정하고 시작 섹터와 마지막 섹터를 지정

```
`n`명령 이후 기본 파티션(`p`), 파티션 번호(1) 등 default 값을 이용하여 생성 및 저장
```



8. `p`명령을 이용하여 파티션이 제대로 설정되었는지 확인하고 `w` 명령을 입력하여 설정한 파티션 정보를 파티션 테이블에 기록 (`USB 메모리에 파티션 생성 완료`)



9. 생성된 USB 메모리 파티션을 포맷하여 리눅스 파일시스템(ex4) 생성 (`mke2fs`)
   `$ sudo mke2fs -t ext4/dev/sdb1`



10. USB 메모리를 마운트(디렉터리에 연결)하고 확인 (`mount`)
    `$ sudo mount /dev/sdb1 /home/user1/linux_ex/ch7/mttest`



11. 테스트를 위하여 USB 메모리에 새로운 파일 복사 (`cp`)
    `$ sudo cp /etc/hosts /home/user1/linux_ex/ch7/mttest` (`새로 마운트 파일 시스템 root만 쓰기권한`)



12. 장치 연결을 해제하고 USB 제거 (`umount`)
    `$ sudo umount /ev/sdb1`

- USB 제거 가능