---
layout: single
title:  "ch8. 파일시스템과 디스크 관리하기(2)"
categories: linux
toc: true
author_profile: false
---

# 4. 디스크 추가 설치

### 디스크 추가 단계
1단계) `새 디스크 장착`

2단계) `디스크 파티션 나누기(fdisk)`

3단계) `파티션에 파일 시스템 생성(포맷)(mkfs)`

4단계) `디스크 마운트(mount)`

### 가상 머신의 디스크 구성도
- `IDE 디스크 컨트롤러 2개`: IDE 0, IDE 1
- `SATA 디스크 컨트롤러 4개`: SATA 0, SATA 1, SATA 2, SATA 3
- `SCSI 디스크 컨트롤러 4개`: SCSI 0, SCSI 1, SCSI 2, SCSI 3   # SCSI 0:0 20G
- `NVMe 컨트롤러 4개`: NVMe 0, NVMe 1, NVMe 2, NVMe 3



### 가상 머신에 디스크 추가하기
- SCSI 0:0 이후 `SCSI 0:1`, `SCSI 0:2`, `SCSI 0:3` 에 `1G` 디스크를 추가



1. Player 메뉴에서 Manage -> `Virtual Machine Settings` 선택, 또는 리눅스 종료 후, VMware Player 화면에서 `Edit virtual machine settings` 선택



2. Virtual Machine Settings 창에서 `Hard Disk` 선택하고 `Add...` 클릭 -> Add Hardware Wizard 창 -> [Next]를 클릭



3. Select a Disk : `Create a new virtual disk`를 선택하고 [Next]를 클릭



4. Select a Disk Type : 디스크 종류는 `SCSI` 선택 [Finish]를 클릭



5. Specify Disk Capacity : 디스크 용량 설정 (테스트 용으로 `1GB`로 설정, Split virtual disk into multiple files 선택) [Next]를 클릭



6. `Specify Disk File` : 가상 디스크의 파일명 지정 (`Virtual Machine Settings` 창에서 새로 생성된 디스크 확인) -> 리눅스 `Power Off` 에서 컴퓨터 다시 시작 선택 (새 하드디스크 인식)

### 디스크 파티션 나누기
- **파티션**: 하나의 디스크를 여러 개의 독립된 영역으로 구분하여 사용
- 디스크 전체를 하나의 파티션으로 사용할 수도 있고 여러 개의 파티션으로 나누어 사용할 수도 있음

### 디스크 장치 이름
- IDE 컨트롤러에 연결된 디스크는 `/dev/hd` 로 시작하는 이름 사용
- SCSI, SATA 컨트롤러에 장착된 디스크는 `/dev/hd` 로 시작하는 이름 사용
- 최근 IDE, SCSI 등 구분 없이 모두 `/deb/hd` 로 시작하는 이름을 사용
- 연결되는 디스크의 순서에 따라 다음과 같이 알파벳 추가
- `/dev/sda`: 첫 번째 디스크
- `/dev/sdb`: 두 번째 디스크
- `/deb/sdc`: 세 번째 디스크

| 디스크명   | 파티션(2개) | 장치명(파일시스템 명) |
| :--------- | :---------- | :-------------------- |
| `/dev/sda` | ------>     | `/dev/sda1`           |
| `/dev/sdb` |             | `/dev/sda2`           |
| `/dev/sdc` |             | ...                   |
| `/dev/sdd` |             | ...                   |

### 디스크 장치 이름과 파티션 표시하기
- 디스크 전체를 하나의 파티션으로 사용할 때도 파티션 작업은 반드시 해야 함
- 하나의 디스크를 여러 개의 파티션으로 구분할 경우 파티션은 디스크 장치 이름의 뒤에 숫자를 붙여서 표시
	- `/dev/sda`: 디스크 전체를 의미하는 디스크명 
	- `/dev/sda1`: 디스크의 첫 번째 파티션명(파일 시스템명)
	- `/dev/sda2`: 디스크의 두 번째 파티션명(파일 시스템명)

### 디스크의 파티션 생성, 삭제, 보기 명령 (`fdisk [옵션][디스크명]`)

| `fdisk` | `# root 권한 필요`                                           |
| :------ | :----------------------------------------------------------- |
| 기능    | 디스크의 파티션을 생성, 삭제, 보기 등 파티션을 관리          |
| 형식    | `fdisk [옵션][장치명]`                                       |
| 옵션    | `-b 크기` : 섹터 크기를 지정한다(512, 1024, 2048, `4096`(기본)), `-l` : 파티션 레이블을 출력한다 |
| 사용 예 | `fdisk /deb/sdb` , `fdisk -l`                                |

#### `fdisk` 명령의 내부 명령

| 명령 | 기능                                           |
| :--- | :--------------------------------------------- |
| `d`  | 파티션을 삭제한다 (`delete`)                   |
| `n`  | 새로운 파티션을 추가한다 (`new`)               |
| `p`  | 파티션 테이블을 출력한다 (`print`)             |
| `q`  | 작업 내용을 저장하지 않고 종료한다 (`q`)       |
| `w`  | 파티션 정보를 디스크에 저장하고 종료한다 (`w`) |

#### `fdisk -l` -`fdisk`로 파티션 정보 보기 
- `$ sudo fdisk -l` (또는 `sudo fdisk -l | grep sd`)

#### 디스크 파티션 나누기
1. `fdisk` 명령 실행 : 파티션 작업을 할 때는 디스크명(`/dev/sdb`)을 인자로 지정
   `$ sudo fdisk /dev/sdb`



2. 새로운 파티션 생성: `n` 을 입력하면 파티션의 종류를 선택 메뉴 출력



3. 파티션 종류 선택: `기본 파티션 선택` -> 파티션 번호 선택 메뉴 출력



4. 파티션 번호 선택: `1 선택`



5. 파티션 크기 설정: First sector : `Enter(default)`
   Last sector: `+500M` 입력



6. 파티션 설정 정보 확인: `p` 입력



7. `n`을 입력하여 두 번째 파티션 생성:

   - 기본 파티션: `p`

   - 파티션 번호: `2`

   - First sector: `Enter(Default)`

   - Last sector: `+500M 입력`

   

8. 파티션 설정 정보 확인: `p` 입력



9. `w`를 입력하여 파티션 설정 정보를 디스크에 기록하고 `fdisk` 종료

### 파일 시스템 생성 (포맷)
- 파일 시스템 생성은 파티션에서 파일과 디렉터리를 관리하기 위한 구조를 만드는 것
- 파일 시스템 생성 명령 (`mkfs` 또는 `mke2fs [옵션] 장치명`)

| `mkfs`  |                                                          |
| :------ | :------------------------------------------------------- |
| 기능    | 리눅스 파일 시스템을 만든다                              |
| 형식    | `mkfs [옵션] 장치명`                                     |
| 옵션    | `-t 종류` : 파일 시스템의 종류를 지정한다(기본값은 ext2) |
| 사용 예 | `mkfs /dev/sdb1`, `mkfs -t ext4 /dev/sdb1`               |

| `mke2fs` |                                                              |
| :------- | :----------------------------------------------------------- |
| 기능     | 리눅스 개정판 확장 파일 시스템(`ext2, ext3, ext4`)을 만든다  |
| 형식     | `mke2fs [옵션] 장치명`                                       |
| 옵션     | `-t 종류` : 파일 시스템의 종류를 지정(기본값은 ext2), `-b 블록 크기` : 블록 크기를 바이트 수로 지정, `-c` : 배드 블록을 체크, `-f 프래그먼트 크기` : 프래그먼트 크기를 바이트 수로 지정, `i inode당 바이트 수` : inode당 바이트 수를 지정(기본값 4.096B), `-m 예약 블록 퍼센트` : 슈퍼유저에게 예약해둘 블록의 퍼센트를 지정(기본값 5%) |
| 사용 예  | `mke2fs /dev/sdb1`, `mke2fs -t ext4 /dev/sdb1`               |

#### `mkfs` 명령으로 파일시스템 생성하기 (포맷)
1. `mkfs` 명령으로 `/dev/sdb1` 파티션에 `ext2` 파일 시스템 생성
   (`-t` 옵션이 없으면 기본은 `ext2` 파일 시스템이 생성)
   `$ sudo mkfs /dev/sdb1`



2. `mkfs -t ext3` 명령으로 `/dev/sdb2` 파티션에 `ext3` 파일 시스템 생성
   `$ sudo mkfs -t ext3 /dev/sdb2`

- `mke2fs`도 똑같이 진행

### 디스크를 마운트 하는 방법
- 파일 시스템을 디렉터리 계층 구조에 마운트(연결)

#### 마운트 포인트 준비하기 (디스크와 연결되는 임의의 디렉터리 만들기)
`$ mkdir /home/user1/linux_ex/ch7/hd1`
`$ mkdir /home/user1/linux_ex/ch7/hd2`

#### 파일 시스템 마운트 하기
- `/dev/sdb1`을 `/mnt/hdd1` 디렉터리에 마운트
	`$ sudo mount /dev/sdb1 /home/user1 /home/user1/linux_ex/ch7/hd1`
- `/dev/sdb2`을 `/mnt/hdd2` 디렉터리에 마운트
	`$ sudo mount /dev/sdb2 /home/user1 /home/user1/linux_ex/ch7/hd1`
- 마운트 결과 확인
	`$ mount` (또는 `mount | grep sd`)

#### 파일 시스템 사용하기 (마운트가 제대로 되었는지 확인)
`$ sudo cp /etc/hosts /home/user1/linux_ex/ch7/hd1`
`$ ls -l /home/user1/;inux_ex/ch7/hd1`

#### 마운트 해제 후, 파일 시스템 다시 확인
```
$ sudo umount /dev/sdb1
$ sudo umount /dev/sdb2
$ ls -l /home/user1/linux_ex/ch7/hd1
```

- 파일 시스템의 마운트가 해제 되면 이 파티션과의 연결이 끊어지므로 `/home/user1/linux_ex/ch7/hd1`에서 `hosts` 파일을 볼 수 없음


---

## 5. 디스크 관리

### 파일 시스템 별 디스크의 남은 공간 확인하기 (`df (disk free)`)

| `df`    |                                                              |
| :------ | :----------------------------------------------------------- |
| 기능    | 디스크의 남은 공간에 대한 정보를 출력한다                    |
| 형식    | `df [옵션] [파일 시스템] `                                   |
| 옵션    | `-a` : 모든 파일 시스템을 대상으로 디스크 사용량을 확인, `-k` : 디스크 사용량을 KB 단위로 출력, `-m` : 디스크 사용량을 MB 단위로 출력, `-h` : 디스크 사용량을 알기 쉬운 단위(GB, MB, KB 등)로 출력, `-t 파일 시스템의 종류` : 지정한 파일 시스템 종류에 해당하는 디스크의 사용량을 출력, `-T` : 파일 시스템 종류도 출력 |
| 사용 예 | `df` , `df -h`                                               |

#### `df` 명령으로 출력되는 항목
- 파일 시스템명
- 파일 시스템의 전체 용량
- 파일 시스템의 사용량
- 파일 시스템의 사용 가능한 용량
- 퍼센트로 나타낸 사용량
- 마운트 포인트 (디렉터리)

#### `df` -`df` 명령만 사용하여 기본 정보 출력
`$ df` (또는 `df | grep sd`)

#### `df -h` -파일 시스템 별로 이해하기 쉬운 단위로 사용량 출력
`$ df -h` (또는 `df -h | grep sd`)

#### `df -T` -파일 시스템 종류(`ext2, ext3, ext4 ...`)도 출력
`$ df -T` (또는 `df -T | grep sd`)

### 디렉터리나 사용자 별 디스크 사용량 확인하기 (`du (disk usage)` )

| `du`    |                                                              |
| :------ | :----------------------------------------------------------- |
| 기능    | 디스크의 사용 공간에 대한 정보를 출력한다                    |
| 형식    | `du [옵션] [디렉터리]`                                       |
| 옵션    | `-s` : 특정 디렉터리의 전체 사용량을 출력, `-h` : 디스크 사용량을 알기 쉬운 단위(GB, MB, KB 등)로 출력 |
| 사용 예 | `du` : 현재 디렉터리의 용량을 보여준다 , `du -s ~user1` : user1의 하루 사용량 , `$ sudo du -sh /usr/bin` |

#### `du` 명령만 사용하는 경우, 현재 디렉터리의 디스크 사용량 출력
`$ du`

#### `du -s` -지정한 디렉터리의 전체 디스크 사용량만 출력 (서브 디렉터리나 파일의 사용량 표시X)
특정 사용자의 디스크 사용량 출력은 그 사용자의 홈 디렉터리를 지정
```
$ du -s
$ du -s ~user1
$ sudo du -s /etc
```

#### `du -h` -디스크 사용량을 알기 쉽게 출력
```
$ du -h
$ du -hs ~user1
```

### 파일 시스템 검사하고 복구하기 (마운트 해제 후 검사)
- 파일 시스템은 `부적절한 시스템 종료, 전원 불안성, 소프트웨어 오류, 하드웨어 오작동 등` 다양한 이유로 손상
- 손상된 파일 시스템의 용량을 확인할 뿐만 아니라 `파일 시스템의 상태를 점검`하고 문제가 있을 때 `복구`해야 함

### `Inode, 블록 디렉터리, 파일 링크 등` 을 검사하고 필요 시 복구 작업 수행 
**(`fcsk (file system check`)**
- `/etc/fstab` 에 지정된 파일시스템을 대상으로 검사 및 복구

### `fsck [옵션] [파일시스템명]` 또는 (`e2fsck [옵션] [파일시스템명]`)
- `mount`를 해제하고 검사 및 복구를 수행해야 함
- 복구 작업은 `/lost+found`의 임시 디렉터리 에서 수행

| `fsck`  |                                                              |
| :------ | :----------------------------------------------------------- |
| 기능    | 리눅스의 파일 시스템을 점검한다                              |
| 형식    | `fsck [옵션] [장치명]`                                       |
| 옵션    | `-f` : 강제로 점검, `-b 슈퍼블록` : 슈퍼블록으로 지정한 백업 슈퍼블록을 사용, `-y` : 모든 질문에 yes로 대답하게 한다, `-a` : 파일 시스템 검사에서 문제를 발견했을 때 자동으로 복구 |
| 사용 예 | `fsck /dev/sdb1` , `fsck -f /dev/sdb1`                       |

#### `fsck` -일반적인 파일시스템 검사
```
$ sudo umount /dev/sdb1
$ sudo fsck /dev/sdb1
```

#### `fsck -f` -파일시스템 강제 검사
```
$ sudo umount /dev/sdb2
$ sudo fsck -f /dev/sdb2
```

### 배드 블록 검사하기 (`badblocks [옵션] [장치명]`)

| `badblocks` |                                                              |
| :---------- | :----------------------------------------------------------- |
| 기능        | 장치의 배드 블록을 검사한다                                  |
| 형식        | `badblocks [옵션] 장치명`                                    |
| 옵션        | `-v` : 검색 결과를 자세하게 출력, `-o 출력 파일` : 검색한 배드 블록 목록을 지정한 출력 파일에 저장 |
| 사용 예     | `badblocks -v /dev/sdb1` , `badblocks -v -o bad.out /dev/sdb1` |

- 배드 블록 검색 자세하게 출력하기 (`badblocks -v`)
`$ sudo badblocks -v /dev/sdb1`

#### `badblocks` -배드 블록 검사하기
- 검색된 배드 블록을 파일로 출력하기 (`badblcoks -o 파일이름`)
`$ sudo badblocks -o bad.out /dev/sdb1`

### 백업 슈퍼 블록을 이용한 파일 시스템 복구하기 (`fsck`로 복구 안되는 경우)
- 파일 시스템의 기본 슈퍼블록에 문제가 있으면 해당 파일 시스템을 사용할 수 없음. 이 경우 백업 슈퍼 블록 중의 하나를 사용하여 파일 시스템을 복구함
- 파일 시스템의 전체 블록그룹 정보를 출력하는 명령 (슈퍼 블록 찾기 위해)
- `dumpe2fs 파일 시스템명`

| `dumpe2fs` |                               |
| :--------- | :---------------------------- |
| 기능       | 파일 시스템의 정보를 출력한다 |
| 형식       | `dumpe2fs 장치명`             |
| 사용 예    | `dumpe2fs /ev/sdb1`           |

- 백업 슈퍼 블록의 위치 파악하기 (`dumpe2fs /dev/sdb1`)
`$ sudo dumpe2fs /dev/sdb1 | grep superblock`

#### 백업 슈퍼 블록을 이용한 파일 시스템 복구하기
파일 시스템 복구하기 (`fsck -b` 이용)
`$ sudo fsck -b 8193 /dev/sdb1` 또는  # `-b` 는 복구하겠냐는 기능 
`$ sudo fsck -b 8193 -y /dev/sdb1`   # `-y`는 질문 하면 모두 yes 




---
## 요약
- 리눅스 파일시스템 종류 (`ext`, `ext2` ,`ext3` ,`ext4`)
- 리눅스 파일시스템 구조 (`ext4 구조`, `파일시스템과 디렉터리 계층`)
- 파일시스템 마운트 (`USB 메모리 연결하기`)
- 디스크 추가 설치 (`파티션` ,`포맷` ,`마운트`) (`fdisk` ,`mkfs` ,`mount`)
- 디스크 관리 (`df`, `du` ,`fsck` ,`badblocks`, `dumpe2fs`, `e2fsck`)