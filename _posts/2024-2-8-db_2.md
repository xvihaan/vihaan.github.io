---
layout: single
title:  "2.데이터베이스 정규화"
categories: [database]
tags: [Major, Database]
toc: true
author_profile: false
---


# 정규화
정규화란 관계형 데이터베이스의 설계에서 데이터 중복을 줄이고 데이터 무결성을 개선하기 위해 데이터를 정규형에 맞도록 구조화하는 프로세스


## 1. 정규화
1. 이상(Anomaly) 현상이 발생하지 않도록 중복성 / 종속성을 최소화하기 위한 작업
2. 논리적 설계 단계에서 수행하며, 속성 수가 적은 테이블로 분할되어 관리가 용이해짐
3. 데이터 구조 안정성 최대화 / 데이터 삽입 시 릴레이션 재구성 필요 최소화

### 이상현상 종류
#### 삽입 이상
데이터 삽입 시 불필요한 데이터가 함께 삽입
#### 삭제 이상
튜플 삭제 시 필요한 데이터도 함께 삭제
#### 갱신 이상
일부만 수정되어 데이터 불일치 -> 정보 모순 발생

### 정규화 과정

| 정규형 종류           | 내용                                                     |
| :--------------- | ------------------------------------------------------ |
| **제 1 정규형**          | 모든 도메인이 원자 값으로만 되어 있음                                  |
| **제 2 정규형**          | 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속 만족하며 부분적 함수 종속을 제거한 정규형  |
| **제 3 정규형**          | 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수 종속 관계를 만족하지 않아야 함        |
| **BCNF<br>(보이스/코드)** | 릴레이션 R에서 모든 결정자가 후보키인 정규형                              |
| **제 4 정규형**          | 릴레이션 R에 다치 종속이 성립하는경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형 |
| **제 5 정규형**          | 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립                      |

#### 반정규화
정규화 과정 진행 후, 시스템 성능 향상 및 운영 편의성을 위해 의도적으로 데이터 중복/통합/분리를 허용하여 정규화 원칙을 위반

#### 함수적 종속

| 함수적 종속 종류 | 내용                                                                            |
| :-------- | ----------------------------------------------------------------------------- |
| 완전 함수적 종속 | ;Full Functional Dependency / 종속자가 기본키에만 종속                                   |
| 부분 함수적 종속 | ;Partial Functional Dependency / 기본키가 여러 속성으로 구성되어 있을 때 기본키를 구성하는 속성 중 일부만 종속 |
| 이행적 함수 종속 | ;Transitive Functional Dependency / X->Y, Y->Z 이면 X->Z                        |

---

## 2. 관계 대수

### 관계 대수
원하는 정보의 검색 과정을 정의하는 절차적 언어

#### 1) 순수 관계 연산자

| 기호   | 종류             | 내용                                                   |
| :--- | -------------- | ---------------------------------------------------- |
| `σ`  | **Select (선택)**    | 조건을 만족하는 튜플들의 부분 집합 (수평 연산)                          |
| `π`  | **Project (추출)**   | 속성들의 부분 집합, 중복 제거 (수칙 연산)                            |
| `▷◁` | **Join (조인)**      | 두 개의 릴레이션을 하나로 합쳐 새로운 릴레이션 형성                        |
| `÷`  | **Division (나누기)** | A의 속성이 B의 속성 값을 모두 가진 튜플에서 B가 가진 속성을 제외한 나머지 속성들만 추출 |

- 세타 조인: 두 릴레이션 속성 값을 비교 후 조건을 만족하는 튜플만 반환
- 동등 조인: 조건이 정확하게 '=' 등호로 일치하는 결과를 반환
- 자연 조인: 동등 조인의 결과에서 중복된 속성을 제거한 결과를 반환

#### 2) 일반 집합 연산

| 기호  | 종류                      | 내용                                                  |
| :-- | ----------------------- | --------------------------------------------------- |
| `∪` | Union (합집합)             | 두 릴레이션의 합 추출 / 중복은 제거                               |
| `∩` | Intersection (교집합)      | 두 릴레이션의 중복되는 값만 추출                                  |
| `-` | Difference (차집합)        | A 릴레이션에서 B 릴레이션 간 중복되지 않는 값을 추출                     |
| `×` | Cartesian Product (교차곱) | 두 릴레이션의 가능한 모든 튜플의 집합<br>-> 속성/컬럼끼리 더하기 / 튜플끼리는 곱하기 |

---
## 3. 관계 해석
원하는 정보가 무엇이라는 것만 정의하는 비절차적 언어

| 종류     | 기호  | 표현     | 내용                           |
| :----- | --- | ------ | ---------------------------- |
| 논리 연산자 | `∨` | OR     | 원자식 간 "또는" 관계로 연결            |
| 논리 연산자 | `∧` | AND    | 원자식 간 "그리고" 관계로 연결           |
| 논리 연산자 | `¬` | NOT    | 원자식에 대한 부정                   |
| 정량자    | `∀` | 전칭 정량자 | 모든 가능한 튜플 "For All"          |
| 정량자    | `∃` | 존재 정량자 | 어떤 튜플 하나라도 존재 "There Exists" |

---
## 4. 트랜잭션

### 트랜잭션
데이터베이스 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업 단위

| 종류  | 내용                                                                |
| :-- | ----------------------------------------------------------------- |
| 원자성 | 트랜잭션 연산이 정상적으로 수행되거나(Commit),<br>아니면 어떠한 연산도 수행되지 않아야 함(Rollback) |
| 일관성 | 시스템의 고정 요소는 트랜잭션 수행 전/후로 동일                                       |
| 독립성 | 개별 트랜잭션은 다른 트랜잭션의 간섭 및 영향 받지 않아야함                                 |
| 영속성 | 완료된 트랜잭션 결과는 영구적으로 기록                                             |

#### COMMIT
트랜잭션 정상 종료 후 변경된 내용을 DB에 반영하는 명령어
#### ROLLBACK
트랜잭션 비정상 종료 후 모든 변경 작업을 취소하고 이전 상태로 원상복구
#### REDO
데이터베이스 비정상 종료 시 트랜잭션 시작과 완료에 대한 기록이 있는 트랜잭션들의 작업을 재작업 (이전 값을 이후 값으로 변경)
#### UNDO
데이터베이스 비정상 종료 시 시작은 있지만 완료 기록이 없는 트랜잭션들이 작업한 내용을 모두 취소 (이후 값을 이전 값으로 변경)


---
## 5. 데이터 회복 기법
### 즉시 갱신 기법
트랜잭션 실행 상태에서 변경되는 내용을 바로 데이터베이스에 적용
-> 변경되는 모든 내용을 로그에 기록하여 장애 시 해당 로그 토대로 복원
-> Redo / Undo 모두 수행
### 지연 갱신 기법
트랜잭션 수행 후 부분 완료될 때 까지는 데이터베이스에 바로 적용하지 않고, 지연시킨 후 부분 완료 시 로그의 내용을 토대로 저장
-> 트랜잭션이 실패할 경우 Undo 수행 없이 Redo만 진행
### 검사 시점 기법
트랜잭션 수행 중간에 검사시점(CheckPoint)을 지정하여 검사시점까지 부분 수행 후 완료된 내용을 중간중간 데이터베이스에 저장
### 그림자 페이징 기법
로그 미사용 / 데이터베이스를 동일 크기의 페이지로 분할 후 각 페이지마다 복사하여 그림자 페이지 보관
-> 변경 내용은 원본 페이지에만 적용하여 장애 발생 시 해당 페이지 사용/회복


---
## 6. 로킹 단위

### 로킹 단위 (Locking)
로킹의 대상이 되는 객체의 크기

### 로킹
데이터베이스 병행 제어를 위해 트랜잭션이 접근하고자 하는 데이터를 잠가(lock) 다른 트랜잭션이 접근하지 못하도록 하는 병행 제어 기법
- 대상: 데이터베이스 / 파일 / 레코드

#### 로킹단위가 떨어진다면
	1. 로크의 수가 증가
		1. 로킹 오버헤드 증가
			1. 병행성(공유도) 증가



#### 로킹단위가 올라간다면
	1. 로크의 수가 감소
		1. 로킹 오버헤드 감소
			1. 병행성(공유도) 감소

### 병행 제어 기법 종류
#### 로킹 기법
일관성과 무결성을 유지하기 위한 트랜잭셔느이 순차적 진행을 보장
(병행 수행 트랜잭션들 간 동일 데이터 접근 차단)
#### 낙관적 검증
일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행
#### 타임 스탬프 기법
타임 스탬프를 부여해 부여된 시간에 따라 트랜잭션 수행
#### 다중버전 동시성 제어(MVCC)
타임 스태프를 비교해 직렬 가능성이 보장되는 적절한 버전을 선택해 접근하도록 함


---
## 7. 분산 데이터베이스
- 논리적으로는 하나의 시스템에 존재하나, 물리적으로는 연결된 다수의 컴퓨터에 분산되어 있는 데이터 베이스

### 구성요소
분산처리기 / 분산 데이터 베이스 / 통신 네트워크

### 목표
- 위치 투명성 (Location)
- 중복 투명성 (Replication)
- 병행 투명성 (Concurrency)
- 분할 투명성 (Division)
- 장애 투명성 (Failure)
-> 사용자 입장에서 데이터베이스의 위치/중복/병행/분할/장애 여부 인식할 필요 X


