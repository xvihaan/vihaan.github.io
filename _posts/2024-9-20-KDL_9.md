---
layout: single
title:  "7.케창딥 - 컴퓨터비전"
categories: [AI, ML, DL]
tags: [keras, deeplearning, KDL]
toc: true
author_profile: false
---


![[Pasted image 20240905104037.png]]

![[Pasted image 20240905104130.png]]


![[Pasted image 20240905104502.png]]

![[Pasted image 20240905105504.png]]

![[Pasted image 20240905105517.png]]

![[Pasted image 20240905105751.png]]


![[Pasted image 20240905110111.png]]

![[Pasted image 20240905105941.png]]

![[Pasted image 20240905110246.png]]


![[Pasted image 20240905110645.png]]

![[Pasted image 20240905110841.png]]

`tf.keras.layers.Depthwise()`


![[Pasted image 20240905111244.png]]

xception은 깊이별 분리 합성곱을 하면서 층 블록에 잔차 연결을 추가하고 합성곱 층 다음에 배치 정규화 층을 추가하는 3가지 아키첵터 패턴을 하나의 모델을 적용한 유사 모델


![[Pasted image 20240905111814.png]]

![[Pasted image 20240905112012.png]]


![[Pasted image 20240905112413.png]]



![[Pasted image 20240905112855.png]]

![[Pasted image 20240905112822.png]]






# 9장 컴퓨터비전, segmantic segmentation

### 세 가지 주요 컴퓨터 비전 작업
---
#### 이미지 분류(image classification)
이미지에 하나 이상의 레이블을 할당하는 것
![[Pasted image 20240928162810.png]]

#### 이미지 분할(image segmentation)
이미지를 다른 영역으로 ‘나누’거나 ‘분할’하는 것
![[Pasted image 20240928163046.png]]

#### 객체 탐지(object detection)
이미지에 있는 관심 객체(바운딩박스) 주변에 사각형을 그리는 것
![[Pasted image 20240928163144.png]]

### 이미지 분할 예제
---

#### 시맨틱 분할(semantic segmentation)
각 픽셀이 독립적으로 하나의 의미를 가진 범주로 분류

#### 인스턴스 분할(instance segmentation)
이미지 픽셀을 범주로 분류하는 것뿐만 아니라 개별 객체 인스턴스를 구분

**Transpose  Convolution**
![[Pasted image 20240928163313.png]]


#### 이미지 분할에서 **다운샘플링 시 최대 풀링이 분할 작업에 상당한 해**를 끼칠 수 있는 이유
---
- 이미지 분할의 경우 모델의 출력으로 픽셀별 타깃 마스크(1:전경, 2:배경, 3:윤곽 과 같은)를 생성해야 하므로 정보의 공간상 위치에 많은 관심을 둔다.
- 2X2 최대 풀링을 사용하게 된다면 풀링 위도우 안의 위치 정보가 완전히 삭제된다.
- 풀링 윈도우마다 하나의 스칼라 값을 반환하는데 이 값들이 윈도우 내의 4가지 위치 중에 어디에서 왔는지에 대한 정보가 없기 때문이다.
- 반면 `스트라이드 합성곱` 의 경우 위치 정보를 유지하면서 다운샘플링하므로 잘 맞는다고 볼 수 있다. 픽셀별로 공간 영향 받는다. 최대풀링은 위치 기준이 아닌 최대값 만 뽑아내니깐) (스트라이드는 위치 정보를 유지하면서 다운샘플링하기 때문에)
- 위치 정보를 유지해 몇 칸씩 뛰는 정보가 있어서 위치 정보가 있다는 것이지. 좌표가 있는 것은 아님

#### **이미지 분할 모델에서 Conv2D 층을 쌓아 다운샘플링**하고, **Conv2DTranspose 층을 쌓아 업샘플링**하는 방식하는 이유
---
- 다운 샘플링 과정의 이유
- 이미지의 공간 정보를 축소하면서 중요한 고수준 특징을 추출하기 위해
- 공간 해상도는 줄어들고 채널 수(필터수)는 증가, 계산량을 줄여 메모리 효율을 높이기 위해
- 업샘플링 과정의 이유
- 축소된 특성 맵을 다시 원본 이미지 크기로 복원, 모델이 픽셀 단위의 예측 가능(정확한 분할)
- 다운샘플링 과정에서 잃어버린 공간 정보 복구
    - 고수준의 추상적 특징을 기반으로 픽셀 수준으로 다시 투영하여 세부 정보를 복구하기 위해
 
#### **요약.**
1. **고수준 특징을 학습**하여 전역적인 맥락 정보를 캡처함으로써, 이미지의 중요한 패턴을 추출
2. 다운샘플링된 특성 맵을 다시 **업샘플링하여 원래 크기로 복구**하고, 세밀한 픽셀 수준의 예측을 가능
3. 인**코더-디코더 구조**는 이미지 분할 문제에서 효과적으로 사용되며, **스킵 연결**을 통해 디테일한 정보 손실을 방지 가능

### 최신 컨브넷 아키텍처 패턴
---
모델을 결정하기 위한 빠르고 정확한 결정

**배치정규화, 잔차연결, 깊이별 합성곱(depthwise convolution)**

### 모듈화, 계층화 그리고 재사용
---
#### 재사용
딥러닝이 발전하고 모델이이 깊어지며 모델을 도돌리는 것이 비용 부담이 되는 시점

#### 반복학습
- 모듈화 : (붙이기만 해도 재사용 가능) 복잡한 구조를 모듈화
- 계층화 : 블록들을 정리한 것
- 재사용 : 추상화. 구조를 다른 상황에도 쓸 수 있도록 만들어

### 재사용의 다른 의미성
---
1. **소프트웨어 아키텍처의 재사용:** 재사용 가능한 클래스(데이터 캡슐화)와 함수를 사용한 것(효율적인 코드는 모듈화)
2. **딥러닝 컨브넷(합성곱)의 재사용:** 다른 공간 위치에서 동일한 정보를 재사용(필터(파라미터)와 이미지가 회전하거나 이동해도 일관된 결과를 내는 공간 불변성) - 패턴 감지에 유용

### 잔차 연결
---
신경망을 쌓는 과정에서 **층이 깊어질수록** 학습이 어려워지거나 **성능이 저하**되는 문제.

이는 **그레디언트 소실**뿐만 아니라, 깊은 네트워크에서 **정보 손실**이 발생함

기울기 0은? 가중치가 더이상 업데이트 되지 않음

⇒ `잔차 연결` 로 해결!
![[Pasted image 20240928163854.png]]
#### 잔차연결 예시
- 입력을 출력에 더하기 위해서는 출력크기가 입력과 같아야함
- Conv층: 입력값을 더하기 위해 Conv층에`padding='same'`으로 다운샘플링을 방지
- MaxPooling층: MaxPooling층의 입력 값을 저장할 때 `strides=2`로 다운샘플링을 맞춤

#### 기울기 소실(vanishing gradient)
- 모델이 깊어질수록, 역전파 과정에서 기울기가 0에 수렴하는 현상
- 층이 깊어져도 성능 개선이 일어나지 않음
- RestNet
- 필터 개수가 늘거나 최대 풀링층을 가진 잔차 블록의 경우 출력 크기와 입력이 같도록 주의 필요
- 다음 단계랑 차이가 나는 것만 배워보자
- 해봤더니 성능이 나아짐, 훨씬 더 깊은 층 사용

### 배치 정규화
---
![[Pasted image 20240928164037.png]]
- 딥러닝 모델의 **내부 공변량 이동**(internal Covariate Shift) 문제를 완화하는 기법
	- 딥러닝 모델의 **각 층**에 입력되는 데이터의 분포가 학습 중에 계속해서 변하는 상황

- **정규화**: 샘플들을 균일하게 만드는 방법, 일반화에 도움
- **미리 정규화**된 데이터 샘플: Conv층에서 출력되는 데이터가 동일한 분포를 가질것이라고 예상하기 어려움
- 훈련하는 동안 현재 배치 데이터의 평균과 분산을 계산하여 정규화(대표성을 가질만큼 충분히 큰 데이터가 아닐 경우 추론에서 훈련 시의 배치 데이터 평균과 분산의 지수 이동 평균을 사용함)

- 배치 정규화가 입력 평균을 0으로 만들지만 relu 활성화 함수는 0을 기준으로 값을 통과시키거나 삭제하기 때문. 활성화 함수 이전에 정규화를 수행하면 relu 함수의 활용도가 극대화

#### 배치 정규화와 미세조정
- 배치정규화는 여러 특이 사항이 있다. 그 중 하나로 미세 조정(fine tuning)과 관련
- Batchnormalization 층이 있는 모델을 미세 조정할 때 이 층들을 동결하는 것이 좋다(false)
- 그렇지 않다면 내부 평균과 분산이 계속 업데이트 되어 Conv2D 층에 적용할 매우 작은 업데이트를 하는 방법


### 깊이별 분리 합성곱
---
![[Pasted image 20240928164252.png]]
![[Pasted image 20240928164300.png]]
- 입력 채널별로 따로따로 공간 방향의 합성곱을 수행(채널 마다 독립적으로 수행하는 공간 방향의 합성곱)

- 점별 합성곱(pointwise convolution)(1x1 합성곱)을 통해 출력 채널을 합침
#### 점별 합성곱?
- 여러 입력 채널을 결합하여 새로운 출력 채널을 생성하는 과정으로, **채널 축에 대한 가중치 합성**을 수행
- 채널 간의 상호작용을 담당함.(1x1 필터)
![[Pasted image 20240928164415.png]]
- 파라미터를 줄이고 속도를 증가시킴. 컨볼루션 단계에서 채널 간 상호작용이 적어진다
- 훨씬 적은 개수의 파라미터 사용, 더 적은 수의 연산 수행
- 수렴이 빠르고 쉽게 과대 적합 되지 않음

#### SeparableConv2D
![[Pasted image 20240928164431.png]]
일반적으로 합성곱에서 channel을 크게 주면 파라미터 수가 급격히 증가하는데,

입력 채널별로 따로따로 공간 방향의 합성곱 수행 후, **1 합성곱 (점별 합성곱)으로 출력 채널을 합치는 것. 이로 인해 공간 특성의 학습과 채널 방향 특성의 학습을 분리하는 효과를 얻을 수 있음.

모델 파라미터와 연산의 수를 크게 줄여주어 더 작고 빠른 모델을 제작할 수 있음.

여기서 1 * 1 합성곱이란,
- 1 * 1 크기의 `Convolution Filter` 사용한 `Convolution Layer` 를 말하는데, Channel / Spatial의 특성파악에 도움이 된다.


## 아키텍처 원칙정리
---
- 모듈화(블록): 일반적으로 여러개의 합성곱, 최대풀링층
- 피라미드계층(좁고 깊은 아키텍처): 특성맵의 공간 방향크기 ↓, 필터 개수 ↑
- 블록에 잔차연결을 추가/합성곱 층 다음에 배치정규화 추가 시 깊은 네트워크에 도움
- 파라미터 효율이 좋은 SeparableConv2D층이 도움될 수 있음

## 컨브넷 학습 해석
---
### 중간 컨브넷 시각화
---
연속된 컨브넷 층이 **입력을 어떻게 변형**시키는지 이해하고, **개별적인 컨브넷 필터의 의미를 파악**하는 데 도움이 된다.
![[Pasted image 20240928164844.png]]

특성 맵을 추출하기 위해 이미지 배치를 입력으로 받아 모든 합성곱과 풀링 층의 활성화를 출력하는 모델 생성
- 다중 출력 모델
- 하나의 입력과 층의 활성화마다 하나씩 총 9개의 출력을 갖는다.

### 클래스별 필터 시각화
---
- 컨브넷의 **필터가 찾으려는 시각적인 패턴과 개념**이 무엇인지 상세하게 이해하는 데 도움
1. 특정 합성곱 층의 한 필터의 값을 최대화하는 손실 함수를 정의
2. 활성화 값을 최대화하기 위해 입력 이미지를 변경하도록 확률적 경사 상승법을 사용
- 입력 이미지는 선택된 필터가 최대로 응답하는 이미지로 생성

### 컨브넷 활성화 히트맵 시각화하기
---
- 어떤 클래스에 속하는 데 **이미지의 어느 부분이 기여**했는지 이해하고 **이미지에서 객체의 위치를 추정**하는 데 도움이 됩니다.
#### 클래스 활성화 맵 (Class Activation Map, CAM)
1. 입력 이미지가 주어지면 합성곱 층에 있는 특성 맵의 출력을 추출
2. 특성 맵의 모든 채널의 출력에 채널에 대한 클래스의 그래디언트 평균을 곱
- 클래스에 대해 각 위치의 중요성
    - 예를 들어 강아지, 고양이 컨브넷에 한 이미지를 주입하면 CAM 시각화는 고양이 클래스에 대한 히트맵을 생성하고 이미지에서 고양이와 비슷한 부분을 알려 준다.
####  Grad-CAM
 **입력 이미지가 각 채널을 활성화하는 정도**에 대한 공간적인 맵을 **클래스에 대한 각 채널의 중요도**로 가중치를 부여하여 **입력 이미지가 클래스를 활성화하는 정도**에 대한 공간적인 맵을 만드는 것.
    ![[Pasted image 20240928165101.png]]

