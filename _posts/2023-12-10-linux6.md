---
layout: single
title:  "[Linux] 6. 프로세스 관리 명령"
categories: linux
tags: [Major, OS]
toc: true
author_profile: false
---

## 1. 프로세스 개념

### 프로세스
- 현재 시스템에서 실행 중인 프로그램
- 사용자 프로세스, 시스템 프로세스

### 프로세스의 부모-자식 관계
- 부모 프로세스는 자식 프로세스를 생성하고, 자식 프로세스는 또 다른 자식 프로세스 생성이 가능
- 자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과 돌려주고 종료

### 프로세스 번호 (PID: process ID number)
- 각 프로세스는 고유한 번호를 가지고 있음
예) `systemd` 또는 `init 프로세스` (PID: 1), `kthreadd` (PID: 2) - `kernal thread daemon`

### 특수한 프로세스의 종류

### 데몬(daemon) 프로세스
- `특정 서비스`를 제공하기 위해 존재하며 리눅스 커널에 의해 자동 실행되는 경우가 많음
- 평소에는 대기상태, 서비스 요청이 들어오면 서비스를 제공
예) `sshd` (원격 접속 서비스 데몬), `httpd` (웹 서비스 데몬), `smtpd` (메일 전송 데몬)

### 고아 프로세스
- 자식 프로세스가 실행 중인데 부모 프로세스가 먼저 종료된 자식 프로세스
- 1번 프로세스(`systemd` 또는 `init`)가 새로운 부모 프로세스가 됨

### 좀비 프로세스
- 프로세스가 실행을 종료했는데도 프로세스 테이블의 목록(`PCB`)에 남아 있는 경우
- 좀비 프로세스가 증가하면 프로세스 테이블의 용량이 부족해서 일반 프로세스가 실행되지 않을 수도 있음

### 콘솔(Console)
- 서버의 `로컬 장치`에서 직접 명령어를 실행할 수 있는 입출력 장치
- `tty` (Tele Type Writer) : 콘솔 터미널 환경

### 터미널
- 서버의 로컬 또는 원격으로 접속할 수 있는 콘솔을 구현한 소프트웨어
- `pts` (Pseudo-Terminal Slave) : `원격 터미널 환경`
- `pty` (Pseudo-Terminal) : `가상 터미널 환경`

---

## 2. 프로세스 관리 명령

### `ps`- 현재 실행 중인 프로세스의 목록을 보는 명령
- `유닉스 옵션(SVR4)` : 묶어서 사용 가능, 붙임표(-)로 시작 (예: `-efpu`)
- `BSD 옵션` : 묶어서 사용 가능, 붙임표(-)로 시작하지 않음 (예: `aux`)
- `GNU 옵션` : 붙임표 두 개로 시작함 (예 : `--pid`)

### `ps` 명령어는 파이프라인으로 `grep`과 많이 사용
```
$ ps -ef | grep bash
# 시스템에서 실행중인 모든 프로세스의 상세한 정보 출력하기
```

## 프로세스 관리 명령 (유닉스 옵션)

### `ps` -현재 실행 중인 프로세스의 목록을 보는 명령
`$ ps`
- ps 명령을 옵션 없이 사용하면 현재 **사용자 프로세스에 대한 정보**를 출력

### `ps -e` -시스템에서 실행 중인 모든 프로세스를 출력 
`$ ps -e`
- 현재 사용자 프로세스를 포함하여 시스템에서 실행 중인 모든 프로세스 정보 출력

### `ps -f` -프로세스의 상세한 정보 출력하기
```
$ ps -f
$ ps -ef | grep system
# ps -ef | grep kthreadd
```


| 항목   | 의미                 | 항목    | 의미                                 |
| :----- | :------------------- | :------ | :----------------------------------- |
| `UID`  | 프로세스를 실행한 ID | `STIME` | 프로세스의 시작 날짜나 시간          |
| `PID`  | 프로세스 번호        | `TTY`   | 프로세스가 실행된 터미널 종류와 번호 |
| `PPID` | 부모 프로세스 번호   | `TIME`  | 프로세스 실행 기간                   |
| `C`    | CPU 사용량(%값)      | `CMD`   | 실행되고 있는 프로그램 이름(명령)    |


### `ps -u 사용자ID` -특정 사용자의 프로세스 정보 출력 
- user1 사용자가 수행한 프로세스 정보 출력
```
$ ps -u user1
$ ps -fu user1
# ps -uf user1 X
```

### `ps -p PID` -PID로 지정한 프로세스 정보 출력
- 특정 PID의 프로세스 정보 출력
```
$ ps -p 1
$ ps -fp 1
# ps -pf 1 X
```

### `pgrep` -지정한 패턴과 일치하는 프로세스 ID 출력하기
`$ pgrep [옵션] 패턴`
#### ba 패턴을 포함하는 모든 프로세스의 PID 출력
`$ pgrep ba`

#### 정확히 bash 와 패턴이 일치하는 프로세스의 PID 출력
`pgrep -x ba` X (이름을 정확하게 입력)

`$ pgrep -x bash`

#### ba 패턴을 포함하는 모든 프로세스의 PID와 명령어 출력
`$ pgrep -l ba`

#### 특정 사용자(user1)에 대하여 ba 패턴을 포함하는 프로세스의 PID, 명령어 출력
특정 사용자: `-u user1`
`$ pgrep -u user1 -l ba`

### 시그널(signal)
- **프로세스에 간단한 메시지를 알리는 것**을 의미
- 리눅스에서 지원하는 시그널의 목록은 `kill -l` 명령으로 알 수 있음
- `$ kill -l`
- 주로 사용하는 시그널(signal)

| 시그널    | 번호 | 기본 처리      | 의미                                                     |
| :-------- | :--- | :------------- | :------------------------------------------------------- |
| `SIGHUP`  | 1    | 종료           | 터미널과의 연결이 끊어졌을 때 발생                       |
| `SIGINT`  | 2    | 종료           | 인터럽트로 사용자가 `Ctrl + c`를 입력하면 발생           |
| `SIGQUIT` | 3    | 종료, 코어덤프 | 종료 신호로 사용자가 `Ctrl + \`을 입력하면 발생          |
| `SIGKILL` | 9    | 종료           | 이 시그널을 받은 프로세스는 무시할 수 없으며 강제로 종료 |
| `SIGALRM` | 14   | 종료           | 알림에 의해 발생                                         |
| `SIGTERM` | 15   | 종료           | kill 명령이 보내는 기본 시그널                           |

### `kill` 명령을 이용해 프로세스 종료하기
`kill [-시그널] PID`
- `시그널 2`: PID 프로세스의 인터럽트(일시멈춤), `Ctrl+c` 명령어로도 수행
- `시그널 9`: PID 프로세스의 강제종료(제일 강력)
- `시그널 15`: PID 프로세스의 종료, 프로세스 시그널을 안 쓰는 경우 기본적으로 15번이 사용됨. 15번은 가끔 프로세스 종료가 안되는 경우가 있음(-15는 생략가능)

#### 추가 터미널(터미널2) 수행 후, `man ps`의 임의 명령어 수행
`$ man ps`

#### 기존 터미널(터미널1)에서 `man 프로세스` 검색
`$ ps -ef` or `$ ps -ef | grep man`

#### `man`을 실행시킨 `프로세스 PID`를 찾아서 종료시키기
`$ kill 135` or `$ kill -15 135`

### `kill` 명령을 이용해 프로세스 종료하기
#### 추가 터미널(터미널2)에서 `sh` 수행
`$ sh`

#### 기존 터미널(터미널1)에서 `sh` 프로세스 검색
`$ ps -fu user1 | grep sh`

#### `sh`를 실행시킨 프로세스 PID를 찾아서 종료시키기
`$ kill 137` (**sh는 kill -15로 종료가 안됨**)
`$ kill -9 137` (**sh는 kill -9로 강제 종료해야 함**)

### `pkill` 명령을 이용해 프로세스 종료하기
- `PID` 가 아니라 프로세스의 명령 이름으로 프로세스를 찾아 종료
- 같은 명령이 여러 개일 경우, 모두 종료
- man이 들어간 모두 프로세스 kill
- `pkill [프로세스패턴]`
- `$ pkill man` (manual 뿐만 아닌 원치 않는 다른 프로세서도 kill 할 수 있음)

### `killall` 명령도 `pkill`가 유사한 기능을 수행함. 명확한 프로세스 이름 입력
- `killall [프로세스이름]`
- `$ killall man`

## `top` -프로세스 관리 도구
- `$ top`
- 현재 실행 중인 프로세스에 대한 정보를 주기적으로 출력 (`작업 관리자와 비슷`)



| 항목   | 의미                                   | 항목      | 의미                                   |
| :----- | :------------------------------------- | :-------- | :------------------------------------- |
| `PID`  | 프로세스 ID                            | `SHR`     | 프로세스가 사용하는 공유 메모리의 크기 |
| `USER` | 사용자 계정                            | `%CPU`    | 퍼센트로 표시한 CPU 사용량             |
| `PR`   | 우선순위                               | `%MEM`    | 퍼센트로 표시한 메모리 사용량          |
| `NI`   | Nice 값                                | `TIME+`   | CPU 누적 이용 시간                     |
| `VIRT` | 프로세스가 사용하는 가상 메모리의 크기 | `COMMAND` | 명령 이름                              |
| `RES`  | 프로세스가 사용하는 메모리의 크기      |           |                                        |

### top 명령의 내부 명령 (`Enter`, `Space Bar`, `k`, `q`)



| 내부 명령          | 기능                                                   |
| :----------------- | :----------------------------------------------------- |
| `Enter, Space Bar` | 화면을 즉시 다시 출력한다.                             |
| `k` (`kill`)       | 프로세스를 종료한다. 종료할 프로세스의 PID를 물어본다. |
| `q`                | top 명령을 종료한다.                                   |


---

## 3. 포그라운드, 백그라운드 프로세스와 작업 제어
### 포그라운드 작업(foreground job): 포그라운드 프로세스
- 사용자가 입력한 명령이 실행되어 결과가 출력될 때까지 기다려야 하는 방식으로 처리되는 프로세스
- 이전 작업이 종료되기 전까지 프롬프트가 출력되지 않아 다른 명령 입력 못함
- `$ sleep 10` (10초간 sleep하는 명령어)

### 백그라운드 작업(background job): 백그라운드 프로세스
- 명령을 실행하면 명령의 처리가 끝나는 것과 관계없이 곧바로 프롬프트가 출력되어 사용자가 다른 명령(작업)을 계속할 수 있음
- `$ sleep 100 &`

### [참고] 파이썬 프로그램의 foreground / background 실행
- vi bg.py 를 실행하여 아래 내용 편집
`$ vi bg.py`
``` python
from time import sleep
 While True :
  print("Test ^^")
  sleep(5)
```

- `bg.py` 프로그램을 foreground 와 background로 실행
`$ python3 bg.py &`  # background
`$ python3 bg.py` # foreground

### 백그라운드 작업과 출력 방향 전환하기
- 백그라운드로 처리할 때는 주로 출력과 오류 방향을 전환하여 실행 결과와 오류 메시지를 파일로 저장할 수 있음
- `$ find / -name passwd >> out 2> out &`

### 작업 제어
- `작업 제어`: 작업 전환, 작업 일시 중지, 작업 종료
- `작업 전환`: 포그라운드 작업 -> 백그라운드 작업
	- 백그라운드 작업 -> 포그라운드 작업
- `작업 일시 중지`: 작업을 잠시 중단함
- `작업 종료`: 프로세스를 종료하는 것처럼 작업을 종료함

### `jobs` -백그라운드 작업 목록 보기
- `jobs` 또는 `jobs [%작업번호]` # 백그라운드 했던 작업들의 목록을 모두 보여준다. (+는 최근의 수행, -는 전 파일)
- `$ jobs`

### jobs 명령 예
```
$ sleep 100 &
$ sleep 200 &
$ sleep 300 &
$ jobs
```

| 항목        | 출력 예     | 의미                                                         |
| :---------- | :---------- | :----------------------------------------------------------- |
| `작업 번호` | [1]         | 작업 번호로서 백그라운드로 실행할 때마다 순차적으로 증가한다([1],[2],[3],..) |
| `작업 순서` | +           | 작업순서를 표시.  `+`: 가장 최근 작업, `-`: + 작업보다 바로 전 작업, `공백`: 그 외의 작업 |
| `상태`      | 우선순위    | 실행중                                                       |
| `명령`      | sleep 100 & | 백그라운드로 실행 중인 명령                                  |

### 작업 전환하기 (포그라운드 -> 백그라운드: `ctrl+z`와 `bg`실행)
- 포그라운드 작업을 잠시 정지 (`ctrl+z`)
```
$ sleep 400
$ ctrl+z
```

- 작업번호가 지시하는 작업을 백그라운드 작업으로 전환 (`bg [%작업번호]`)
- bg 명령에서 작업번호를 지시하지 않는 경우, 작업순서가 +인 작업이 백그라운드 작업으로 전환
`$ bg %1` or `$ bg`
- Jobs 명령으로 위의 작업이 백그라운드 작업으로 되었는지 확인
`$ jobs`

### 작업 전환하기 (백그라운드 -> 포그라운드: `fg` 실행)
- Jobs 명령으로 백그라운드 작업 조회
`$ jobs`
- 작업번호가 지시하는 작업을 포그라운드 작업으로 전환 (`fg [%작업번호]`)
- fg 명령에서도 작업번호를 지시하지 않는 경우, 작업순서가 +인 작업이 포그라운드 작업으로 전환됨
`$ fg %1` or `$ fg`

### `ctrl+c` -작업 종료하기
- 포그라운드 작업은 `ctrl+c` 를 입력하면 대부분 종료
`$ sleep 100`
`ctrl+c`

- 백그라운드 작업은 `kill` 명령으로 강제 종료 (PID 또는 %작업 번호 이용) 또는 포그라운드 작업으로 벼경하여 ctrl+c 실행
`$ sleep 100 &`
[1] 5312
`$ kill 5312` or `$ kill %1`

### `nohup` -로그아웃 후에도 백그라운드 작업 계속 실행하기 
`$ nohub find / -name passwd &`
- 리다이렉션이 없어도 기본적으로 nohup.out 파일에 위의 수행 결과가 저장

(참고)
`$ nohup find / -name passwd >> out 2 > out &`
`nohup.out`파일이 아니라, 사용자가 지정한 `out`파일에 위의 수행결과가 저장(리다이렉션 추가 가능)

## 실습
```
# /etc/hosts 파일 복사하고, vi hosts 실행, vi hosts 작업 일시 정지
$ cp /etc/hosts .
$ vi hosts
$ ctrl+z

# jobs 명령으로 백그라운드에서 정지되어 있는 작업 확인
$ jobs

# 정지 중인 vi 작업을 포그라운드로 복구
$ fg

# 종료
:q!
```


---

## 4. 작업 예약
특정한 시간에 작업을 수행하도록 예약할 수 있는 방법
- `at` -정해진 시간에 한 번만 수행하기 
- `crontab` -정해진 시간에 반복 수행하기

### `at` 명령 설치(현재 `at` 명령어 설치되어 있지 않음. `mailutils`도 추후 사용을 위해 설치)
`$ sudo apt-get install at
`$ sudo apt-get install mailutils`

- 추가 설치 요청은 `yes` 선택
- `mailutils` 설치 시, 인터넷사이트 선택 & `Enter `키 입력

### `at` 명령 설정하기
- 정해진 시간에 명령을 실행하도록 예약하려면 at 명령 뒤에 시간을 명시
- 시간 설정 방법
	- `at 4pm + 3 days` : 지금부터 3일 후 오후 4시에 작업 수행
	- `at 10am Jul 31` : 7월 31일 오전 10시에 작업 수행  ex) `at 10:32am Nov 6`
	- `at 1am tomorrow` : 내일 오전 1시에 작업 수행
	- `at 10:00am today` : 오늘 오전 10시에 작업 수행
- `at` 로 실행할 실제 명령은 표준 입력으로 지정하며, 명령의 입력을 마치려면 `ctrl+d` 입력
```
$ at 07:00 pm
warning: commands will be executes using /bin/sh
at> /bin/ls -l ~user1 > ~user1/at.out
at> ctrl+d
```

### `at -l` 또는 `atq` -at 작업 목록 확인하기
`$ at -l` or `$ atq` # root 권한
- 슈퍼유저(root)일 경우, `atq` 명령으로 모든 사용자의 `at` 작업 목록을 확인할 수 있음

### `at -d 목록번호` 또는 `atrm 목록번호` -at 작업 목록 삭제하기
- at 명령으로 설정한 작업이 실행되기 전에 삭제는 -d 옵션을 사용하고 삭제할 작업 번호를 지정
```
$ at 1 am tomorrow
warning: commands will be executes using /bin/sh
at> /bin/ls -l ~user1 > ~user1/at1.out
at> ctrl+d
```

```
$ at 2 pm tomorrow
warning: commands will be executes using /bin/sh
at> /bin/ls -l /tmp > ~user1/at2.out
at> ctrl+d

```

```
$ atq   # 작업확인
$ at -d 1   # 1번 예약삭제
$ atrm 2   # 2번 예약삭제
$ at -l   # 작업 확인
```

### `at` 명령으로 생성한 작업 파일 확인
- `/var/spool/cron/atjobs` 디렉터리에 저장됨 (일반 사용자는 접근권한 없음)
`$ sudo ls -l /var/spool/cron/atjobs`
- 꼭 sudo 붙여야 함.
- `sudo ls -ld /var/spool/cron/atjobs` -디렉터리 파일 정보 보기
- `atjobs` 는 `스티키비트(T)` 가 권한. 누구나 파일을 만들어 올릴 수 있다.

### `at` 명령 사용 제한하기
- 관련 파일: `/etc/at.allow` 와 `/etc/at.deny`
- `/etc/at.allow와 /etc/at.deny 파일에 한 줄에 사용자 이름을 하나씩 기록`
- 두 파일의 적용 기준
	- `/etc/at.allow` 파일이 있으면 이 파일 안에 있는 사용자만 at 명령 사용 가능
	- `/etc/at.deny` 파일만 있으면 이 파일에 사용자가 없어야 at 명령 가능
	- `/etc/at.deny` 를 빈 파일로 두면 모든 사용자가 at 명령 사용 가능 (초기 상태)

### `crontab` -정해진 시간에 반복 실행
- `crontab` 이용하여 정해진 시간에 반복 실행하는 명령을 포함하는 파일 생성

- `crontab` 파일 내부의 형식 (예)

| 분(0~59) | 시(0~23 | 일(1~31) | 월(1~12) | 요일(0~6) | 작업 내용                            |
| :------- | :------ | :------- | :------- | :-------- | :----------------------------------- |
| `30`     | `23`    | `1`      | `*`      | `*`       | `bin/ls -l ~user1 > ~user1/cron.out` |

### `crontab -e` -사용자의 crontab 파일 생성하고 편집하기 
- `crontab` 명령의 편집기는 선택할 수 있으며, 미리 설정도 가능
- `EDITOR` 환경변수를 `vi`로 설정하고 `crontab -e` 실행



```
$ EDITOR=vi; export EDITOR
# 또는 export EDITOR=vi

$ crontab -e
# crontab 파일의 가장 마지막에 아래 내용을 편집하고 저장
30 23 1 * * /bin/ls -l ~user1 > ~user1/cron.out
```

### `crontab -l` -crontab 편집 내용 확인 
`$ crontab -l`

#### `crontab -e` 명령으로 편집한 파일은 `/var/spool/cron/crontabs` 디렉터리에 사용자 이름으로 생성됨 (일반 사용자는 접근권한 없음)  - <스티키비트설정>
`$ sudo ls -l /var/spool/cron/crontabs`

#### `crontab -r` 수행 후 `crontab -l` -crontab 파일 삭제하고 다시 확인하기
```
$ crontab -r
$ crontab -l
```

### `crontab` 명령 사용 제한하기
- 관련 파일: `/etc/cron.allow, /etc/cron.deny`
- `cron.deny` 파일은 기본적으로 있지만 `cron.allow` 파일은 관리자가 만들어야 함
- 두 파일의 적용 기준
	- `/etc/cron.allow` 파일이 있으면 이 파일 안에 있는 사용자만 crontab 명령 사용 가능
	- `/etc/cron.deny` 파일만 있으면 이 파일에 사용자가 없어야 crontab 명령 가능


## 실습
```
# 1. crontab -e 명령으로 crontab 파일 편집
$ crontab -e
00 16 7 * * /bin/ls -l/tmp > /home/user1/linux_ex/ch6/tmp.out

# 2. crontab -l 명령으로 설정 내용 확인
$ crontab -l

# 3. crontab에 설정한 시간 경과한 후 작업 결과 확인
$ cat tmp.out
```



---

## 요약

- 프로세스 개념 (`시스템 프로세스, 사용자 프로세스, PID`)
- 시스템 프로세스 종류 (`데몬, 고아, 좀비`)
- 프로세스 관리 명령 (`ps, pgrep, kill, pkill, killall, top`)
- 포그라운드와 백그라운드 작업 관리 명령 (`jobs, fg, ctrl+c, bg, ctrl+z`)
- 자동 작업 관리 (`at, crontab`)